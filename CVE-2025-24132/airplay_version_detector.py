
#!/usr/bin/env python3
"""
Enhanced AirPlay Version Detector
For network security education and research purposes only.
Use only on networks you own or have explicit permission to test.

This script implements multiple techniques to detect AirPlay device versions
for vulnerability assessment related to CVE-2025-24132.
"""

import socket
import sys
import re
import time
import logging
import argparse
import json
import os
import binascii
import xml.etree.ElementTree as ET
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from http.client import HTTPResponse
from io import BytesIO

# Constants
AIRPLAY_PORTS = [7000, 5000, 7100, 49152, 49153]
VULNERABLE_VERSIONS = {
    "airplay_sdk": "2.7.1",         # Vulnerable if < 2.7.1
    "airplay_video_sdk": "3.6.0.126",  # Vulnerable if < 3.6.0.126
    "carplay_plugin": "R18.1"       # Vulnerable if < R18.1
}

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('AirPlayVersionDetector')

# ANSI colors for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


class FakeSocket():
    """Used to parse HTTP responses with http.client.HTTPResponse"""
    def __init__(self, response_bytes):
        self._file = BytesIO(response_bytes)
    
    def makefile(self, *args, **kwargs):
        return self._file


class NetworkUtils:
    """Network utility functions"""
    
    @staticmethod
    def get_local_ip():
        """Get the local IP address of this machine"""
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # doesn't need to be reachable
            s.connect(('10.255.255.255', 1))
            IP = s.getsockname()[0]
        except Exception:
            IP = '127.0.0.1'
        finally:
            s.close()
        return IP
    
    @staticmethod
    def get_network_range(ip_address):
        """Convert IP address to network range for scanning"""
        try:
            # Detect if the IP is a CIDR network
            if '/' in ip_address:
                return ipaddress.IPv4Network(ip_address, strict=False)
            # Otherwise assume a /24 network
            return ipaddress.IPv4Network(f"{ip_address.rsplit('.', 1)[0]}.0/24", strict=False)
        except Exception as e:
            logger.error(f"Error determining network range: {e}")
            sys.exit(1)
    
    @staticmethod
    def scan_port(ip, port, timeout=2):
        """Scan a single IP and port combination"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((ip, port))
        sock.close()
        return port if result == 0 else None


class HTTPUtils:
    """HTTP utility functions"""
    
    @staticmethod
    def parse_http_response(response_data, verbose=False):
        """Parse HTTP response data into headers and body"""
        try:
            # Use HTTPResponse to parse the HTTP response
            source = FakeSocket(response_data)
            response = HTTPResponse(source)
            response.begin()
            
            # Read headers
            headers = {k.lower(): v for k, v in response.getheaders()}
            
            # Read body
            body = response.read()
            
            return {
                "status_code": response.status,
                "headers": headers,
                "body": body
            }
        except Exception as e:
            if verbose:
                logger.debug(f"Failed to parse HTTP response: {e}")
                logger.debug(f"Raw response preview: {response_data[:100]}...")
            
            # Fallback to manual parsing
            try:
                header_end = response_data.find(b'\r\n\r\n')
                if header_end > 0:
                    headers_data = response_data[:header_end].decode('utf-8', errors='ignore')
                    body = response_data[header_end+4:]
                    
                    # Parse status line
                    status_line = headers_data.split('\r\n')[0]
                    status_parts = status_line.split(' ', 2)
                    status_code = int(status_parts[1]) if len(status_parts) > 1 else 0
                    
                    # Parse headers
                    headers = {}
                    for line in headers_data.split('\r\n')[1:]:
                        if ': ' in line:
                            key, value = line.split(': ', 1)
                            headers[key.lower()] = value
                    
                    return {
                        "status_code": status_code,
                        "headers": headers,
                        "body": body
                    }
            except Exception as e2:
                if verbose:
                    logger.debug(f"Fallback parsing also failed: {e2}")
            
            # If all parsing fails, return a minimal structure
            return {
                "status_code": 0,
                "headers": {},
                "body": response_data
            }


class VersionUtils:
    """Version utility functions"""
    
    @staticmethod
    def is_version_vulnerable(version_str, threshold):
        """Compare version strings to determine if current version is vulnerable"""
        try:
            # Handle special format for R versions (CarPlay)
            if version_str.startswith('R') and threshold.startswith('R'):
                version_num = float(version_str[1:]) if '.' in version_str else int(version_str[1:])
                threshold_num = float(threshold[1:]) if '.' in threshold else int(threshold[1:])
                return version_num < threshold_num
            
            # Normal version comparison
            version_parts = [int(p) if p.isdigit() else p for p in version_str.split('.')]
            threshold_parts = [int(p) if p.isdigit() else p for p in threshold.split('.')]
            
            # Pad with zeros if needed
            while len(version_parts) < len(threshold_parts):
                version_parts.append(0)
            while len(threshold_parts) < len(version_parts):
                threshold_parts.append(0)
            
            # Compare each part
            for i in range(len(version_parts)):
                if version_parts[i] < threshold_parts[i]:
                    return True
                elif version_parts[i] > threshold_parts[i]:
                    return False
            
            # If all parts are equal, it's at the threshold (not vulnerable)
            return False
        except Exception as e:
            logger.debug(f"Error comparing versions: {str(e)}")
            # If we can't parse the version, assume it might be vulnerable
            return True


class AirPlayProtocol:
    """AirPlay protocol implementation"""
    
    def __init__(self, timeout=2, verbose=False):
        self.timeout = timeout
        self.verbose = verbose
        
        # AirPlay protocol headers
        self.headers = {
            "User-Agent": "AirPlay/420.3",
            "Content-Type": "application/x-apple-binary-plist",
            "X-Apple-Device-ID": "0x1122334455667788",
            "X-Apple-Session-ID": binascii.hexlify(os.urandom(8)).decode('utf-8')
        }
    
    def create_request(self, method, path, body=None, additional_headers=None):
        """Create an AirPlay HTTP request"""
        headers = self.headers.copy()
        if additional_headers:
            headers.update(additional_headers)
        
        headers_str = "\r\n".join([f"{k}: {v}" for k, v in headers.items()])
        
        if body:
            request = (
                f"{method} {path} HTTP/1.1\r\n"
                f"{headers_str}\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"\r\n"
            )
            if isinstance(body, str):
                request += body
            else:
                request = request.encode('utf-8') + body
        else:
            request = (
                f"{method} {path} HTTP/1.1\r\n"
                f"{headers_str}\r\n"
                f"\r\n"
            )
            if not isinstance(request, bytes):
                request = request.encode('utf-8')
        
        return request
    
    def send_request(self, ip, port, method, path, body=None, additional_headers=None):
        """Send an HTTP request to the AirPlay device and get the response"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((ip, port))
            
            # Add Host header
            host_headers = {"Host": f"{ip}:{port}"}
            if additional_headers:
                host_headers.update(additional_headers)
            
            # Send request
            request = self.create_request(method, path, body, host_headers)
            sock.sendall(request)
            
            # Receive response with a larger buffer for complete data
            response_data = b''
            start_time = time.time()
            while time.time() - start_time < self.timeout:
                try:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    response_data += chunk
                    
                    # If we've got a complete response, stop reading
                    if b'\r\n\r\n' in response_data and not (
                        b'Content-Length:' in response_data and 
                        len(response_data) < 10000):
                        break
                except socket.timeout:
                    break
            
            sock.close()
            
            # If we received data, try to parse it
            if response_data:
                return response_data
            
            return None
        
        except Exception as e:
            logger.debug(f"Error in {method} {path} request: {str(e)}")
            return None
    
    def send_rtsp_request(self, ip, port):
        """Send an RTSP OPTIONS request to the device"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((ip, port))
            
            # Send RTSP OPTIONS request
            request = (
                f"OPTIONS rtsp://{ip}:{port}/stream RTSP/1.0\r\n"
                f"CSeq: 1\r\n"
                f"User-Agent: AirPlay/420.3\r\n"
                f"\r\n"
            ).encode('utf-8')
            
            sock.sendall(request)
            
            # Receive response
            response_data = b''
            start_time = time.time()
            while time.time() - start_time < self.timeout:
                try:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    response_data += chunk
                    
                    # If we've got a complete response, stop reading
                    if b'\r\n\r\n' in response_data and not (
                        b'Content-Length:' in response_data and 
                        len(response_data) < 10000):
                        break
                except socket.timeout:
                    break
            
            sock.close()
            
            # If we received data, return it
            if response_data:
                return response_data
            
            return None
        
        except Exception as e:
            logger.debug(f"Error in RTSP request: {str(e)}")
            return None


class AirPlayVersionProbe:
    """AirPlay version detection implementation"""
    
    def __init__(self, timeout=2, verbose=False):
        self.timeout = timeout
        self.verbose = verbose
        self.protocol = AirPlayProtocol(timeout, verbose)
    
    def get_version_server_info(self, ip, port):
        """Get version information using /server-info endpoint"""
        response_data = self.protocol.send_request(ip, port, "GET", "/server-info")
        
        if not response_data:
            return {
                "status": "failed",
                "method": "server-info",
                "reason": "No response data",
                "raw_data": None
            }
        
        parsed = HTTPUtils.parse_http_response(response_data, self.verbose)
        
        if parsed["status_code"] == 200:
            # Try to extract version info from body
            version_info = {}
            
            # Method 1: Look for XML/plist format
            if b'<?xml' in parsed["body"] or b'<plist' in parsed["body"]:
                try:
                    # Try to parse as XML
                    root = ET.fromstring(parsed["body"])
                    for elem in root.iter():
                        if 'version' in elem.tag.lower() or 'model' in elem.tag.lower():
                            version_info[elem.tag] = elem.text
                except Exception as e:
                    if self.verbose:
                        logger.debug(f"Failed to parse XML: {e}")
            
            # Method 2: Look for key-value pairs in the response
            body_text = parsed["body"].decode('utf-8', errors='ignore')
            
            # Common patterns for version information
            patterns = [
                r'(\w+)\s*=\s*"([^"]+)"',   # Key="Value" pattern
                r'(\w+)\s*:\s*([^\r\n]+)',  # Key: Value pattern
                r'(\w+)\s*=\s*([^\s;]+)'    # key=value (without quotes)
            ]
            
            for pattern in patterns:
                matches = re.findall(pattern, body_text)
                for key, value in matches:
                    key = key.lower()
                    # Focus on version-related keys
                    if any(x in key for x in ['version', 'model', 'sdk', 'fw', 'build', 'srcvers']):
                        version_info[key] = value
            
            # Check headers for version info
            for header, value in parsed["headers"].items():
                if any(x in header.lower() for x in ['version', 'server', 'model']):
                    version_info[header] = value
            
            return {
                "status": "success",
                "method": "server-info",
                "version_info": version_info,
                "response": parsed,
                "raw_data": response_data[:1000] if self.verbose else None
            }
        else:
            # Even if we don't get a 200 OK, check headers for version info
            version_info = {}
            for header, value in parsed["headers"].items():
                if any(x in header.lower() for x in ['version', 'server', 'model']):
                    version_info[header] = value
            
            if version_info:
                return {
                    "status": "partial",
                    "method": "server-info",
                    "version_info": version_info,
                    "response": parsed,
                    "raw_data": response_data[:1000] if self.verbose else None
                }
            
            return {
                "status": "failed",
                "method": "server-info",
                "reason": f"Got status code {parsed['status_code']}",
                "response": parsed,
                "raw_data": response_data[:1000] if self.verbose else None
            }
    
    def get_version_info_endpoint(self, ip, port):
        """Get version information using /info endpoint"""
        response_data = self.protocol.send_request(ip, port, "GET", "/info")
        
        if not response_data:
            return {
                "status": "failed",
                "method": "info",
                "reason": "No response data",
                "raw_data": None
            }
        
        parsed = HTTPUtils.parse_http_response(response_data, self.verbose)
        
        # Check for version info in headers and body
        version_info = {}
        
        # Extract from headers
        for header, value in parsed["headers"].items():
            if any(x in header.lower() for x in ['version', 'server', 'model', 'x-apple']):
                version_info[header] = value
        
        # Try to extract from body if present
        if parsed["body"] and len(parsed["body"]) > 0:
            try:
                body_text = parsed["body"].decode('utf-8', errors='ignore')
                
                # Look for version patterns in body
                version_patterns = [
                    r'version\s*[=:]\s*"?([0-9\.]+)"?',
                    r'v?([0-9]+\.[0-9]+\.[0-9]+(?:\.[0-9]+)?)',
                    r'build\s*[=:]\s*"?([0-9\.]+)"?'
                ]
                
                for pattern in version_patterns:
                    match = re.search(pattern, body_text)
                    if match:
                        version_info['extracted_version'] = match.group(1)
                        break
                
                # Look for model information
                model_patterns = [
                    r'model\s*[=:]\s*"?([^"]+)"?',
                    r'deviceid\s*[=:]\s*"?([^"]+)"?'
                ]
                
                for pattern in model_patterns:
                    match = re.search(pattern, body_text)
                    if match:
                        version_info['model'] = match.group(1)
                        break
            except:
                pass
        
        if version_info:
            return {
                "status": "success" if parsed["status_code"] == 200 else "partial",
                "method": "info",
                "version_info": version_info,
                "response": parsed,
                "raw_data": response_data[:1000] if self.verbose else None
            }
        
        return {
            "status": "failed",
            "method": "info",
            "reason": f"No version info found, status code {parsed['status_code']}",
            "response": parsed,
            "raw_data": response_data[:1000] if self.verbose else None
        }
    
    def get_version_status_endpoint(self, ip, port):
        """Get version information using /status endpoint"""
        response_data = self.protocol.send_request(ip, port, "GET", "/status")
        
        if not response_data:
            return {
                "status": "failed",
                "method": "status",
                "reason": "No response data",
                "raw_data": None
            }
        
        parsed = HTTPUtils.parse_http_response(response_data, self.verbose)
        
        version_info = {}
        
        # Check headers for version info
        for header, value in parsed["headers"].items():
            if any(x in header.lower() for x in ['version', 'server']):
                version_info[header] = value
        
        # Look for version patterns in body
        if parsed["body"] and len(parsed["body"]) > 0:
            try:
                body_text = parsed["body"].decode('utf-8', errors='ignore')
                
                # Look for version patterns
                patterns = [
                    r'version\s*[=:]\s*"?([0-9\.]+)"?',
                    r'build\s*[=:]\s*"?([0-9\.]+)"?',
                    r'firmware\s*[=:]\s*"?([0-9\.]+)"?'
                ]
                
                for pattern in patterns:
                    match = re.search(pattern, body_text)
                    if match:
                        version_info['body_version'] = match.group(1)
                        break
            except:
                pass
        
        if version_info:
            return {
                "status": "success" if parsed["status_code"] == 200 else "partial",
                "method": "status",
                "version_info": version_info,
                "response": parsed,
                "raw_data": response_data[:1000] if self.verbose else None
            }
        
        return {
            "status": "failed",
            "method": "status",
            "reason": f"No version info found, status code {parsed['status_code']}",
            "response": parsed,
            "raw_data": response_data[:1000] if self.verbose else None
        }
    
    def get_version_rtsp_options(self, ip, port):
        """Try to get version using RTSP OPTIONS command (used by some AirPlay devices)"""
        response_data = self.protocol.send_rtsp_request(ip, port)
        
        if not response_data:
            return {
                "status": "failed",
                "method": "rtsp",
                "reason": "No response data",
                "raw_data": None
            }
        
        version_info = {}
        
        # Parse the response manually since it's RTSP
        try:
            lines = response_data.decode('utf-8', errors='ignore').split('\r\n')
            
            # Extract info from response headers
            for line in lines:
                if ': ' in line:
                    key, value = line.split(': ', 1)
                    if 'server' in key.lower() or 'version' in key.lower():
                        version_info[key] = value
            
            if version_info:
                return {
                    "status": "success" if "RTSP/1.0 200" in lines[0] else "partial",
                    "method": "rtsp",
                    "version_info": version_info,
                    "raw_data": response_data[:1000] if self.verbose else None
                }
            
            return {
                "status": "failed",
                "method": "rtsp",
                "reason": "No version info found",
                "raw_data": response_data[:1000] if self.verbose else None
            }
        except Exception as e:
            logger.debug(f"Error parsing RTSP response: {str(e)}")
            
            return {
                "status": "error",
                "method": "rtsp",
                "reason": str(e),
                "raw_data": response_data[:1000] if self.verbose else None
            }
    
    def comprehensive_version_check(self, ip, port):
        """Try multiple methods to get version information"""
        logger.info(f"Checking {ip}:{port} for version information...")
        
        # Initialize result structure
        result = {
            "ip": ip,
            "port": port,
            "version_found": False,
            "version_info": {},
            "model": "Unknown",
            "version": "Unknown",
            "potentially_vulnerable": True,
            "vulnerability_reasons": [],
            "methods_tried": [],
            "methods_succeeded": []
        }
        
        # Try multiple methods to get version info
        methods = [
            self.get_version_server_info,
            self.get_version_info_endpoint,
            self.get_version_status_endpoint,
            self.get_version_rtsp_options
        ]
        
        for method in methods:
            method_name = method.__name__.replace("get_version_", "")
            result["methods_tried"].append(method_name)
            
            # Try the method
            method_result = method(ip, port)
            
            if method_result["status"] in ["success", "partial"]:
                result["methods_succeeded"].append(method_name)
                
                # Extract version info
                if "version_info" in method_result:
                    for key, value in method_result["version_info"].items():
                        result["version_info"][key] = value
            
            # Break early if we've found good info
            if len(result["version_info"]) > 2:
                break
        
        # Process the collected version information
        if result["version_info"]:
            result["version_found"] = True
            
            # Try to determine the model
            model_keys = ["model", "hw_model", "device", "devicemodel"]
            for key in model_keys:
                if key in result["version_info"]:
                    result["model"] = result["version_info"][key]
                    break
            
            # Try to find server header which often contains version
            if "server" in result["version_info"]:
                server_header = result["version_info"]["server"]
                # Example: AirTunes/130.14
                match = re.search(r'([A-Za-z]+)/([0-9\.]+)', server_header)
                if match:
                    result["version_info"]["server_type"] = match.group(1)
                    result["version_info"]["server_version"] = match.group(2)
                    result["version"] = match.group(2)
            
            # Look for explicit version fields
            version_keys = [
                "version", "srcvers", "fw_version", "firmware", "sw_version",
                "extracted_version", "body_version", "server_version", "fv"
            ]
            
            for key in version_keys:
                if key in result["version_info"]:
                    result["version"] = result["version_info"][key]
                    break
            
            # Check if vulnerable
            result["potentially_vulnerable"] = False
            
            # If version is still unknown, assume vulnerable
            if result["version"] == "Unknown":
                result["potentially_vulnerable"] = True
                result["vulnerability_reasons"].append("Unknown version - cannot verify if patched")
            else:
                # Check against known vulnerable thresholds
                version = result["version"]
                
                # CarPlay check
                if "carplay" in str(result["model"]).lower() and VersionUtils.is_version_vulnerable(
                    version, VULNERABLE_VERSIONS["carplay_plugin"]):
                    result["potentially_vulnerable"] = True
                    result["vulnerability_reasons"].append(
                        f"CarPlay version {version} is older than {VULNERABLE_VERSIONS['carplay_plugin']}")
                
                # AirPlay SDK check
                elif "sdk" in str(result["model"]).lower() and "video" in str(result["model"]).lower():
                    if VersionUtils.is_version_vulnerable(
                        version, VULNERABLE_VERSIONS["airplay_video_sdk"]):
                        result["potentially_vulnerable"] = True
                        result["vulnerability_reasons"].append(
                            f"AirPlay Video SDK version {version} is older than {VULNERABLE_VERSIONS['airplay_video_sdk']}")
                
                # General AirPlay check
                elif VersionUtils.is_version_vulnerable(version, VULNERABLE_VERSIONS["airplay_sdk"]):
                    result["potentially_vulnerable"] = True
                    result["vulnerability_reasons"].append(
                        f"AirPlay version {version} is older than {VULNERABLE_VERSIONS['airplay_sdk']}")
        else:
            # No version info found, but device responds to AirPlay ports
            result["vulnerability_reasons"].append(
                "Device has AirPlay port open but doesn't provide version info - potentially vulnerable")
        
        # Log the result
        if result["potentially_vulnerable"]:
            logger.warning(f"{Colors.FAIL}Device at {ip}:{port} is POTENTIALLY VULNERABLE{Colors.ENDC}")
            logger.warning(f"{Colors.FAIL}Reasons: {', '.join(result['vulnerability_reasons'])}{Colors.ENDC}")
        else:
            logger.info(f"{Colors.GREEN}Device at {ip}:{port} appears to be PATCHED{Colors.ENDC}")
        
        if result["version_found"]:
            logger.info(f"Model: {result['model']}, Version: {result['version']}")
            if self.verbose:
                logger.debug(f"All version info: {json.dumps(result['version_info'], indent=2)}")
        
        return result


class MDNSDiscovery:
    """mDNS discovery for AirPlay devices"""
    
    def __init__(self, callback_fn=None, timeout=5, verbose=False):
        self.timeout = timeout
        self.verbose = verbose
        self.callback_fn = callback_fn
        self.devices = {}
        
        # Import zeroconf here to handle import errors
        try:
            from zeroconf import ServiceBrowser, Zeroconf
            self.zeroconf_available = True
            self.Zeroconf = Zeroconf
            self.ServiceBrowser = ServiceBrowser
        except ImportError:
            logger.error("zeroconf module not found. Please install it with: pip install zeroconf")
            self.zeroconf_available = False
    
    def discover(self):
        """Discover AirPlay devices using mDNS"""
        if not self.zeroconf_available:
            logger.error("zeroconf module not available, cannot perform mDNS discovery")
            return {}
        
        logger.info(f"{Colors.HEADER}Looking for AirPlay devices with mDNS...{Colors.ENDC}")
        
        zeroconf = self.Zeroconf()
        listener = self._create_listener()
        browser_airplay = self.ServiceBrowser(zeroconf, "_airplay._tcp.local.", listener)
        browser_raop = self.ServiceBrowser(zeroconf, "_raop._tcp.local.", listener)
        
        # Give mDNS some time to discover devices
        logger.info(f"Listening for mDNS announcements for {self.timeout} seconds...")
        time.sleep(self.timeout)
        zeroconf.close()
        
        return self.devices
    
    def _create_listener(self):
        """Create a listener for mDNS services"""
        
        class AirPlayListener:
            def __init__(self, discovery):
                self.discovery = discovery
            
            def add_service(self, zeroconf, service_type, name):
                info = zeroconf.get_service_info(service_type, name)
                if info:
                    addresses = [f"{socket.inet_ntoa(addr)}" for addr in info.addresses]
                    for address in addresses:
                        logger.info(f"{Colors.GREEN}Found AirPlay device via mDNS: {address} ({info.server}){Colors.ENDC}")
                        
                        # Extract information from TXT records
                        txt_records = {}
                        for k, v in info.properties.items():
                            if k and v:
                                try:
                                    txt_records[k.decode('utf-8')] = v.decode('utf-8')
                                except:
                                    pass
                        
                        # Prepare basic device info
                        device_info = {
                            "ip": address,
                            "hostname": info.server,
                            "port": info.port,
                            "open_ports": [info.port],
                            "service_name": name,
                            "detection_methods": ["mDNS"],
                            "version_info": txt_records,
                            "potentially_vulnerable": True,
                            "vulnerability_reasons": ["Detected via mDNS as AirPlay device"],
                            "model": "Unknown",
                            "version": "Unknown"
                        }
                        
                        # Extract model and version from TXT records if available
                        if 'model' in txt_records:
                            device_info["model"] = txt_records['model']
                        
                        # Look for version information in TXT records
                        version_keys = ["version", "fv", "srcvers", "protovers"]
                        for key in version_keys:
                            if key in txt_records:
                                device_info["version"] = txt_records[key]
                                break
                        
                        # Check if potentially vulnerable based on version
                        if device_info["version"] != "Unknown":
                            # Determine if potentially vulnerable
                            version = device_info["version"]
                            
                            # Default to not vulnerable if we have a version
                            device_info["potentially_vulnerable"] = False
                            
                            # Check against known vulnerable thresholds
                            # CarPlay check
                            if "carplay" in str(device_info["model"]).lower() and VersionUtils.is_version_vulnerable(
                                version, VULNERABLE_VERSIONS["carplay_plugin"]):
                                device_info["potentially_vulnerable"] = True
                                device_info["vulnerability_reasons"].append(
                                    f"CarPlay version {version} is older than {VULNERABLE_VERSIONS['carplay_plugin']}")
                            
                            # AirPlay SDK check
                            elif "sdk" in str(device_info["model"]).lower() and "video" in str(device_info["model"]).lower():
                                if VersionUtils.is_version_vulnerable(
                                    version, VULNERABLE_VERSIONS["airplay_video_sdk"]):
                                    device_info["potentially_vulnerable"] = True
                                    device_info["vulnerability_reasons"].append(
                                        f"AirPlay Video SDK version {version} is older than {VULNERABLE_VERSIONS['airplay_video_sdk']}")
                            
                            # General AirPlay check
                            elif VersionUtils.is_version_vulnerable(version, VULNERABLE_VERSIONS["airplay_sdk"]):
                                device_info["potentially_vulnerable"] = True
                                device_info["vulnerability_reasons"].append(
                                    f"AirPlay version {version} is older than {VULNERABLE_VERSIONS['airplay_sdk']}")
                        
                        # Save the device and call callback if provided
                        self.discovery.devices[address] = device_info
                        
                        if self.discovery.callback_fn:
                            self.discovery.callback_fn(device_info)
            
            # Add these methods to avoid warnings
            def update_service(self, zeroconf, service_type, name):
                pass
            
            def remove_service(self, zeroconf, service_type, name):
                pass
        
        return AirPlayListener(self)


class AirPlayVersionDetector:
    """Main class for AirPlay version detection"""
    
    def __init__(self, target_ip=None, target_range=None, output_dir="airplay_scan_results", 
                 scan_timeout=2, verbose=False, output_format="json"):
        self.target_ip = target_ip
        self.target_range = target_range
        self.output_dir = output_dir
        self.scan_timeout = scan_timeout
        self.verbose = verbose
        self.output_format = output_format
        
        # Results storage
        self.discovered_devices = {}
        
        # Create scanner objects
        self.prober = AirPlayVersionProbe(scan_timeout, verbose)
        
        # Import ipaddress here to handle import errors
        try:
            import ipaddress
            self.ipaddress = ipaddress
            self.ipaddress_available = True
        except ImportError:
            logger.error("ipaddress module not found. Please install it with: pip install ipaddress")
            self.ipaddress_available = False
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # Setup logging to file
        self.log_file = os.path.join(output_dir, f"airplay_version_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        file_handler = logging.FileHandler(self.log_file)
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        logger.addHandler(file_handler)
        
        if verbose:
            logger.setLevel(logging.DEBUG)
    
    def on_device_discovered(self, device_info):
        """Callback when a device is discovered via mDNS"""
        self.discovered_devices[device_info["ip"]] = device_info
        
        if device_info["potentially_vulnerable"]:
            logger.warning(f"{Colors.FAIL}Device appears POTENTIALLY VULNERABLE: {device_info['ip']}{Colors.ENDC}")
        else:
            logger.info(f"{Colors.GREEN}Device appears PATCHED: {device_info['ip']}{Colors.ENDC}")
    
    def scan_target_ip(self, ip):
        """Scan a specific IP for AirPlay services and check version"""
        logger.info(f"{Colors.HEADER}Scanning {ip} for AirPlay services...{Colors.ENDC}")
        
        # Check for open AirPlay ports
        open_ports = []
        for port in AIRPLAY_PORTS:
            port_result = NetworkUtils.scan_port(ip, port, self.scan_timeout)
            if port_result:
                open_ports.append(port_result)
        
        if not open_ports:
            logger.info(f"No AirPlay ports found on {ip}")
            return None
        
        logger.info(f"{Colors.BLUE}Found AirPlay ports on {ip}: {', '.join(map(str, open_ports))}{Colors.ENDC}")
        
        # For each open port, try to get version information
        results = []
        for port in open_ports:
            version_result = self.prober.comprehensive_version_check(ip, port)
            if version_result:
                results.append(version_result)
        
        # Combine results if multiple ports were checked
        if results:
            # Use the most informative result (the one with the most version info)
            best_result = max(results, key=lambda r: len(r.get("version_info", {})))
            
            # Store the result
            device_result = {
                "ip": ip,
                "open_ports": open_ports,
                "model": best_result.get("model", "Unknown"),
                "version": best_result.get("version", "Unknown"),
                "version_info": best_result.get("version_info", {}),
                "potentially_vulnerable": best_result.get("potentially_vulnerable", True),
                "vulnerability_reasons": best_result.get("vulnerability_reasons", []),
                "detection_methods": best_result.get("methods_succeeded", [])
            }
            
            self.discovered_devices[ip] = device_result
            return device_result
        
        return None
    
    def scan_network(self):
        """Scan the network for AirPlay devices"""
        if not self.ipaddress_available:
            logger.error("ipaddress module not available, cannot perform network scan")
            return
            
        if self.target_range:
            network = self.ipaddress.IPv4Network(self.target_range, strict=False)
        else:
            local_ip = NetworkUtils.get_local_ip()
            network = NetworkUtils.get_network_range(local_ip)
        
        logger.info(f"{Colors.HEADER}Scanning network {network} for AirPlay devices...{Colors.ENDC}")
        
        # Prepare target list
        target_ips = [str(ip) for ip in network.hosts()]
        total_hosts = len(target_ips)
        
        logger.info(f"Scanning {total_hosts} hosts for AirPlay services")
        
        # Multi-threaded scanning
        with ThreadPoolExecutor(max_workers=100) as executor:
            futures = [executor.submit(self.scan_target_ip, ip) for ip in target_ips]
            for future in futures:
                # Just wait for completion, results are stored in self.discovered_devices
                future.result()
    
    def export_results(self, filename=None):
        """Export results to a file"""
        if not filename:
            filename = os.path.join(self.output_dir, f"airplay_version_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{self.output_format}")
        
        # Prepare export data
        export_data = {
            "scan_info": {
                "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "target_ip": self.target_ip,
                "target_range": self.target_range,
                "total_devices": len(self.discovered_devices),
                "vulnerable_devices": sum(1 for device in self.discovered_devices.values() 
                                         if device.get("potentially_vulnerable", True))
            },
            "devices": self.discovered_devices
        }
        
        # Export based on format
        if self.output_format == "json":
            with open(filename, 'w') as f:
                json.dump(export_data, f, indent=4)
        elif self.output_format == "txt":
            with open(filename, 'w') as f:
                f.write(f"AirPlay Version Scan Report\n")
                f.write(f"Generated: {export_data['scan_info']['timestamp']}\n\n")
                
                f.write(f"Scan Summary:\n")
                f.write(f"  Total devices found: {export_data['scan_info']['total_devices']}\n")
                f.write(f"  Potentially vulnerable: {export_data['scan_info']['vulnerable_devices']}\n\n")
                
                f.write(f"Device Details:\n")
                f.write(f"=" * 80 + "\n\n")
                
                for ip, device in export_data['devices'].items():
                    f.write(f"IP: {ip}\n")
                    f.write(f"Model: {device.get('model', 'Unknown')}\n")
                    f.write(f"Version: {device.get('version', 'Unknown')}\n")
                    f.write(f"Open ports: {', '.join(map(str, device.get('open_ports', [])))}\n")
                    f.write(f"Potentially vulnerable: {device.get('potentially_vulnerable', True)}\n")
                    
                    if device.get('vulnerability_reasons'):
                        f.write(f"Vulnerability reasons:\n")
                        for reason in device.get('vulnerability_reasons', []):
                            f.write(f"  - {reason}\n")
                    
                    f.write(f"Detection methods: {', '.join(device.get('detection_methods', []))}\n")
                    
                    if device.get('version_info'):
                        f.write(f"Version information:\n")
                        for key, value in device.get('version_info', {}).items():
                            f.write(f"  {key}: {value}\n")
                    
                    f.write(f"\n" + "=" * 80 + "\n\n")
        else:
            logger.error(f"Unsupported output format: {self.output_format}")
            return None
        
        logger.info(f"{Colors.GREEN}Results exported to {filename}{Colors.ENDC}")
        return filename
    
    def list_discovered_devices(self):
        """Print information about discovered devices"""
        if not self.discovered_devices:
            logger.warning(f"{Colors.WARNING}No AirPlay devices discovered.{Colors.ENDC}")
            return
            
        logger.info(f"\n{Colors.HEADER}{Colors.BOLD}Discovered AirPlay Devices:{Colors.ENDC}")
        logger.info("-" * 80)
        
        vulnerable_count = sum(1 for device in self.discovered_devices.values() 
                             if device.get("potentially_vulnerable", True))
        
        logger.info(f"Found {len(self.discovered_devices)} AirPlay devices, {vulnerable_count} potentially vulnerable")
        logger.info("")
        
        for ip, device in self.discovered_devices.items():
            if device.get("potentially_vulnerable", True):
                risk_indicator = f"{Colors.FAIL}POTENTIALLY VULNERABLE{Colors.ENDC}"
            else:
                risk_indicator = f"{Colors.GREEN}LIKELY PATCHED{Colors.ENDC}"
                
            logger.info(f"Device: {Colors.BOLD}{device.get('model', 'Unknown AirPlay Device')}{Colors.ENDC}")
            logger.info(f"IP Address: {ip}")
            logger.info(f"Version: {device.get('version', 'Unknown')}")
            logger.info(f"Security Status: {risk_indicator}")
            logger.info(f"Open AirPlay Ports: {', '.join(map(str, device.get('open_ports', [])))}")
            
            if device.get("hostname"):
                logger.info(f"Hostname: {device.get('hostname')}")
            
            if device.get("vulnerability_reasons"):
                logger.info(f"Vulnerability Indicators:")
                for reason in device.get("vulnerability_reasons", []):
                    logger.info(f"  - {reason}")
            
            logger.info("-" * 80)
    
    def print_security_recommendations(self):
        """Print security recommendations"""
        logger.info(f"\n{Colors.HEADER}Security Recommendations:{Colors.ENDC}")
        logger.info("1. Update all Apple devices to the latest OS versions")
        logger.info("2. Update firmware on third-party AirPlay devices if updates are available")
        logger.info("3. Consider network segmentation for devices that cannot be updated")
        logger.info("4. Disable AirPlay on devices not actively using it")
        logger.info("5. Monitor for suspicious AirPlay activities on your network")
    
    def run(self):
        """Run a complete version scan"""
        logger.info(f"{Colors.BOLD}{Colors.HEADER}")
        logger.info("=" * 80)
        logger.info("         Enhanced AirPlay Version Detector for CVE-2025-24132           ")
        logger.info("         For security education and testing only                        ")
        logger.info("=" * 80)
        logger.info(f"{Colors.ENDC}")
        
        # Start with mDNS discovery
        mdns = MDNSDiscovery(self.on_device_discovered, timeout=5, verbose=self.verbose)
        mdns.discover()
        
        # If a specific target was specified, scan it
        if self.target_ip:
            self.scan_target_ip(self.target_ip)
        # Otherwise scan the network range if needed
        elif self.target_range or not self.discovered_devices:
            self.scan_network()
        
        # Print and export results
        self.list_discovered_devices()
        results_file = self.export_results()
        
        # Print security recommendations
        self.print_security_recommendations()
        
        logger.info(f"\n{Colors.WARNING}This check was performed for educational and security purposes only.{Colors.ENDC}")
        logger.info(f"{Colors.WARNING}Results saved to: {results_file}{Colors.ENDC}")
        
        return len(self.discovered_devices) > 0


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Enhanced AirPlay Version Detector for CVE-2025-24132 - For security education and testing only',
        epilog='Example: %(prog)s -t 192.168.1.10 -v'
    )
    
    parser.add_argument('-t', '--target', help='Target IP address to scan')
    parser.add_argument('-r', '--range', help='Target IP range in CIDR notation (e.g., 192.168.1.0/24)')
    parser.add_argument('-o', '--output', help='Output directory for scan results')
    parser.add_argument('-f', '--format', choices=['json', 'txt'], default='json', help='Output format')
    parser.add_argument('-s', '--timeout', type=float, default=2.0, help='Timeout for connection attempts')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Setup output directory
    output_dir = args.output if args.output else "airplay_scan_results"
    
    detector = AirPlayVersionDetector(
        target_ip=args.target,
        target_range=args.range,
        output_dir=output_dir,
        scan_timeout=args.timeout,
        verbose=args.verbose,
        output_format=args.format
    )
    
    detector.run()


if __name__ == "__main__":
    main()