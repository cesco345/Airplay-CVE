#!/usr/bin/env python3
"""
AirPlay Protocol Educational Simulator
For network security education and testing purposes only.
Use only on networks you own or have explicit permission to test.

This script demonstrates AirPlay protocol concepts and can be used
to test detection systems without exploiting actual vulnerabilities.
"""

import socket
import sys
import argparse
import time
import random
import binascii
import threading
import logging
import os
import io

# Try to import required packages
try:
    from zeroconf import ServiceBrowser, ServiceInfo, Zeroconf
    import ipaddress
    from PIL import Image, ImageDraw, ImageFont
except ImportError:
    missing = []
    for pkg in ['zeroconf', 'pillow']:
        try:
            __import__(pkg)
        except ImportError:
            missing.append(pkg)
    
    if missing:
        print("Missing required packages: " + ", ".join(missing))
        print("Please install them with: pip install " + " ".join(missing))
        sys.exit(1)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('AirPlaySimulator')

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

class AirPlaySimulator:
    def __init__(self, target_ip, target_port=7000, mode="display", display_text="Security Test", 
                 display_image=None, verbose=False):
        self.target_ip = target_ip
        self.target_port = target_port
        self.mode = mode
        self.display_text = display_text
        self.display_image = display_image
        self.verbose = verbose
        
        # AirPlay protocol simulation constants
        self.airplay_headers = {
            "User-Agent": "AirPlay/420.3",
            "Content-Type": "application/x-apple-binary-plist",
            "X-Apple-Device-ID": "0x1122334455667788",
            "X-Apple-Session-ID": binascii.hexlify(os.urandom(8)).decode('utf-8')
        }
        
        # Test image to display if no image is provided
        self.test_image_path = None
        
        if verbose:
            logger.setLevel(logging.DEBUG)
    
    def generate_test_image(self):
        """Generate a test image with security notice"""
        img = Image.new('RGB', (800, 600), color=(0, 0, 0))
        draw = ImageDraw.Draw(img)
        
        # Try to load a font, or use default if not available
        try:
            font = ImageFont.truetype("Arial.ttf", 40)
            small_font = ImageFont.truetype("Arial.ttf", 20)
        except IOError:
            font = ImageFont.load_default()
            small_font = ImageFont.load_default()
        
        # Draw warning text
        draw.text((50, 100), "SECURITY TEST IMAGE", fill=(255, 0, 0), font=font)
        draw.text((50, 200), f"Text: {self.display_text}", fill=(255, 255, 255), font=font)
        draw.text((50, 300), f"Target: {self.target_ip}:{self.target_port}", fill=(255, 255, 255), font=font)
        draw.text((50, 400), "This device may be vulnerable to AirBorne", fill=(255, 255, 0), font=font)
        draw.text((50, 500), "Educational use only - Not an exploit", fill=(0, 255, 0), font=small_font)
        
        # Save to a temporary file
        img_byte_arr = io.BytesIO()
        img.save(img_byte_arr, format='PNG')
        img_byte_arr.seek(0)
        
        return img_byte_arr.getvalue()
    
    def discover_airplay_devices(self):
        """Discover AirPlay devices on the network using mDNS"""
        logger.info(f"{Colors.HEADER}Discovering AirPlay devices on the network...{Colors.ENDC}")
        
        class AirPlayListener:
            def __init__(self):
                self.devices = {}
                
            def add_service(self, zeroconf, service_type, name):
                info = zeroconf.get_service_info(service_type, name)
                if info:
                    addresses = [f"{socket.inet_ntoa(addr)}" for addr in info.addresses]
                    for address in addresses:
                        self.devices[address] = {
                            "ip": address,
                            "hostname": info.server,
                            "port": info.port,
                            "name": name,
                            "txt_records": {k.decode('utf-8'): v.decode('utf-8') 
                                          for k, v in info.properties.items() if k and v}
                        }
                        logger.info(f"Discovered AirPlay device: {address} ({info.server})")
            
            # Add update_service method to prevent warning
            def update_service(self, zeroconf, service_type, name):
                pass
            
            # Add remove_service method
            def remove_service(self, zeroconf, service_type, name):
                pass
        
        listener = AirPlayListener()
        zeroconf = Zeroconf()
        
        try:
            browser_airplay = ServiceBrowser(zeroconf, "_airplay._tcp.local.", listener)
            browser_raop = ServiceBrowser(zeroconf, "_raop._tcp.local.", listener)
            
            logger.info("Listening for AirPlay devices (waiting 5 seconds)...")
            time.sleep(5)  # Give time for discovery
            
            if not listener.devices:
                logger.warning(f"{Colors.WARNING}No AirPlay devices discovered.{Colors.ENDC}")
                if self.target_ip:
                    logger.info(f"Will still attempt to connect to specified target: {self.target_ip}")
            else:
                logger.info(f"{Colors.GREEN}Discovered {len(listener.devices)} AirPlay devices:{Colors.ENDC}")
                for ip, device in listener.devices.items():
                    logger.info(f"  {Colors.BOLD}{ip}{Colors.ENDC} - {device['hostname']} (Port: {device['port']})")
                    
                    if self.verbose and 'txt_records' in device and device['txt_records']:
                        for key, value in device['txt_records'].items():
                            logger.debug(f"    {key}: {value}")
            
            return listener.devices
        finally:
            zeroconf.close()
    
    def simulate_airplay_connection(self):
        """Simulate an AirPlay connection to the target device"""
        logger.info(f"{Colors.HEADER}Simulating AirPlay connection to {self.target_ip}:{self.target_port}{Colors.ENDC}")
        
        try:
            # Create a socket connection to the target
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target_ip, self.target_port))
            logger.info(f"{Colors.GREEN}Connected to {self.target_ip}:{self.target_port}{Colors.ENDC}")
            
            # Send initial AirPlay request
            http_request = self._create_airplay_request("GET", "/server-info")
            sock.sendall(http_request.encode('utf-8'))
            
            # Try to receive a response
            try:
                response = sock.recv(4096)
                logger.info(f"{Colors.GREEN}Received response from server:{Colors.ENDC}")
                if self.verbose:
                    logger.debug(response)
                else:
                    logger.info(f"  Response length: {len(response)} bytes")
            except socket.timeout:
                logger.warning(f"{Colors.WARNING}No response received from server (timeout){Colors.ENDC}")
            
            sock.close()
            return True
            
        except Exception as e:
            logger.error(f"{Colors.FAIL}Failed to connect: {str(e)}{Colors.ENDC}")
            return False
    
    def _create_airplay_request(self, method, path, body=None):
        """Create a simulated AirPlay HTTP request"""
        headers = "\r\n".join([f"{k}: {v}" for k, v in self.airplay_headers.items()])
        
        if body:
            request = (
                f"{method} {path} HTTP/1.1\r\n"
                f"Host: {self.target_ip}:{self.target_port}\r\n"
                f"{headers}\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"\r\n"
            )
            request += body
        else:
            request = (
                f"{method} {path} HTTP/1.1\r\n"
                f"Host: {self.target_ip}:{self.target_port}\r\n"
                f"{headers}\r\n"
                f"\r\n"
            )
        
        return request
    
    def simulate_display_image(self):
        """Simulate displaying an image on the target device"""
        logger.info(f"{Colors.HEADER}Attempting to display image on {self.target_ip}:{self.target_port}{Colors.ENDC}")
        
        try:
            # Generate image data
            if self.display_image and os.path.exists(self.display_image):
                with open(self.display_image, 'rb') as f:
                    image_data = f.read()
                logger.info(f"Using provided image: {self.display_image}")
            else:
                image_data = self.generate_test_image()
                logger.info("Using generated test image")
            
            # Create a socket connection to the target
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target_ip, self.target_port))
            
            # First check if the server is ready
            http_request = self._create_airplay_request("GET", "/server-info")
            sock.sendall(http_request.encode('utf-8'))
            
            try:
                response = sock.recv(4096)
                if b"HTTP/1.1 200" not in response:
                    logger.warning(f"{Colors.WARNING}Server didn't respond with 200 OK{Colors.ENDC}")
            except socket.timeout:
                logger.warning(f"{Colors.WARNING}No response received from server for /server-info{Colors.ENDC}")
            
            # Then try to send the image
            # Note: This is a simplified simulation and may not work on actual devices
            # For educational purposes only
            
            # Method 1: Try using PUT /photo
            logger.info("Attempting to send image via PUT /photo...")
            http_request = self._create_airplay_request("PUT", "/photo", image_data)
            sock.sendall(http_request.encode('utf-8'))
            
            try:
                response = sock.recv(4096)
                if b"HTTP/1.1 200" in response:
                    logger.info(f"{Colors.GREEN}Successfully sent image via PUT /photo{Colors.ENDC}")
                else:
                    logger.warning(f"{Colors.WARNING}Failed to send image via PUT /photo{Colors.ENDC}")
                    
                    # Try Method 2: POST /slideshows
                    logger.info("Attempting alternative method via POST /slideshows...")
                    
                    # Create a simplified plist wrapper
                    wrapper = f"""<?xml version="1.0" encoding="UTF-8"?>
                    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
                    <plist version="1.0">
                    <dict>
                        <key>images</key>
                        <array>
                            <data>{binascii.b2a_base64(image_data).decode('utf-8')}</data>
                        </array>
                    </dict>
                    </plist>"""
                    
                    http_request = self._create_airplay_request("POST", "/slideshows", wrapper)
                    sock.sendall(http_request.encode('utf-8'))
                    
                    try:
                        response = sock.recv(4096)
                        if b"HTTP/1.1 200" in response:
                            logger.info(f"{Colors.GREEN}Successfully sent image via POST /slideshows{Colors.ENDC}")
                        else:
                            logger.warning(f"{Colors.WARNING}Failed to send image via alternative method{Colors.ENDC}")
                    except socket.timeout:
                        logger.warning(f"{Colors.WARNING}No response received for POST /slideshows{Colors.ENDC}")
            
            except socket.timeout:
                logger.warning(f"{Colors.WARNING}No response received for PUT /photo{Colors.ENDC}")
            
            sock.close()
            return True
            
        except Exception as e:
            logger.error(f"{Colors.FAIL}Failed to display image: {str(e)}{Colors.ENDC}")
            return False
    
    def run(self):
        """Run the AirPlay simulator in the specified mode"""
        logger.info(f"{Colors.BOLD}{Colors.HEADER}")
        logger.info("=" * 80)
        logger.info("           AirPlay Protocol Educational Simulator           ")
        logger.info("       For network security education and testing only      ")
        logger.info("=" * 80)
        logger.info(f"{Colors.ENDC}")
        
        # Start with discovery to confirm target or find devices
        devices = self.discover_airplay_devices()
        
        # If no target is specified and devices were found, use the first one
        if not self.target_ip and devices:
            self.target_ip = list(devices.keys())[0]
            self.target_port = devices[self.target_ip]["port"]
            logger.info(f"{Colors.BLUE}No target specified. Using discovered device: {self.target_ip}:{self.target_port}{Colors.ENDC}")
        
        if not self.target_ip:
            logger.error(f"{Colors.FAIL}No target specified and no devices discovered.{Colors.ENDC}")
            return False
        
        # Run the appropriate simulation mode
        if self.mode == "connect":
            return self.simulate_airplay_connection()
        elif self.mode == "display":
            return self.simulate_display_image()
        elif self.mode == "scan":
            # Just do a connection test and report
            return self.simulate_airplay_connection()
        else:
            logger.error(f"{Colors.FAIL}Invalid mode: {self.mode}{Colors.ENDC}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description='AirPlay Protocol Educational Simulator - For security education and testing only',
        epilog='Example: %(prog)s -t 192.168.1.10 -m display -i test.png'
    )
    
    parser.add_argument('-t', '--target', help='Target IP address (required unless discovery finds devices)')
    parser.add_argument('-p', '--port', type=int, default=7000, help='Target port (default: 7000)')
    parser.add_argument('-m', '--mode', choices=['connect', 'display', 'scan'], default='display',
                      help='Simulation mode: connect, display, scan (default: display)')
    parser.add_argument('-i', '--image', help='Path to image file to display (for display mode)')
    parser.add_argument('-x', '--text', default='Security Test', help='Text to display (for display mode)')
    parser.add_argument('-d', '--discover', action='store_true', help='Only discover devices, don\'t simulate')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose logging')
    
    args = parser.parse_args()
    
    if args.discover:
        simulator = AirPlaySimulator("0.0.0.0", verbose=args.verbose)
        simulator.discover_airplay_devices()
        return
    
    if not args.target:
        print(f"{Colors.WARNING}No target specified. Will attempt to discover devices.{Colors.ENDC}")
    
    simulator = AirPlaySimulator(
        args.target, 
        args.port, 
        args.mode, 
        args.text, 
        args.image, 
        args.verbose
    )
    
    simulator.run()

if __name__ == "__main__":
    main()
