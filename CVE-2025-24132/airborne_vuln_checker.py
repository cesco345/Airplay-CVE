#!/usr/bin/env python3
"""
AirBorne Vulnerability Checker (CVE-2025-24132)
For network security education and research purposes only.
Use only on networks you own or have explicit permission to test.

This script identifies devices potentially vulnerable to the AirBorne
vulnerabilities (CVE-2025-24132) in Apple's AirPlay protocol.
"""

import socket
import sys
import re
import time
import threading
import logging
import argparse
import json
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

# Try to import required packages
try:
    import ipaddress
    from zeroconf import ServiceBrowser, Zeroconf
except ImportError:
    missing = []
    for pkg in ['ipaddress', 'zeroconf']:
        try:
            __import__(pkg)
        except ImportError:
            missing.append(pkg)
    
    if missing:
        print("Missing required packages: " + ", ".join(missing))
        print("Please install them with: pip install " + " ".join(missing))
        sys.exit(1)

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('AirBorneChecker')

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

class AirBorneChecker:
    def __init__(self, target_range=None, output_dir="airborne_scan", verbose=False):
        self.target_range = target_range
        self.output_dir = output_dir
        self.verbose = verbose
        
        # Tracking for discovered devices
        self.discovered_devices = {}
        
        # AirPlay ports and protocol information
        self.airplay_ports = [5000, 7000, 7100, 49152, 49153]
        
        # Vulnerability indicators
        self.vulnerable_signatures = [
            {"version": "AirPlay SDK < 2.7.1", "risk": "HIGH", "cve": "CVE-2025-24132"},
            {"version": "AirPlay Video SDK < 3.6.0.126", "risk": "HIGH", "cve": "CVE-2025-24132"},
            {"version": "CarPlay Communication Plug-in < R18.1", "risk": "HIGH", "cve": "CVE-2025-24132"}
        ]
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # Setup logging to file
        self.log_file = os.path.join(output_dir, f"airborne_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        file_handler = logging.FileHandler(self.log_file)
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        logger.addHandler(file_handler)
        
        if verbose:
            logger.setLevel(logging.DEBUG)
    
    def get_local_ip(self):
        """Get the local IP address of this machine"""
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # doesn't need to be reachable
            s.connect(('10.255.255.255', 1))
            IP = s.getsockname()[0]
        except Exception:
            IP = '127.0.0.1'
        finally:
            s.close()
        return IP
    
    def get_network_range(self, ip_address):
        """Convert IP address to network range for scanning"""
        try:
            # Assume a /24 network
            network = ipaddress.IPv4Network(f"{ip_address.rsplit('.', 1)[0]}.0/24", strict=False)
            return network
        except Exception as e:
            logger.error(f"Error determining network range: {e}")
            sys.exit(1)
    
    def scan_port(self, ip, port):
        """Scan a single IP and port combination"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.5)
        result = sock.connect_ex((ip, port))
        sock.close()
        return port if result == 0 else None
    
    def check_device_info(self, ip, port):
        """Check if device responds to AirPlay info requests"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((ip, port))
            
            # Send GET /server-info request
            request = ("GET /server-info HTTP/1.1\r\n"
                      f"Host: {ip}:{port}\r\n"
                      "User-Agent: AirPlay/420.3\r\n"
                      "\r\n")
            
            sock.sendall(request.encode('utf-8'))
            
            # Try to receive response
            response = sock.recv(4096)
            sock.close()
            
            # Check if we got a valid response
            if b"HTTP/1.1 200" in response:
                logger.debug(f"Got server-info response from {ip}:{port}")
                
                device_info = {}
                
                # Parse device information
                if b"model" in response:
                    model_match = re.search(rb'model\s*=\s*"([^"]+)"', response)
                    if model_match:
                        device_info["model"] = model_match.group(1).decode('utf-8')
                
                if b"deviceid" in response:
                    deviceid_match = re.search(rb'deviceid\s*=\s*"([^"]+)"', response)
                    if deviceid_match:
                        device_info["device_id"] = deviceid_match.group(1).decode('utf-8')
                
                # Check for version information
                if b"version" in response:
                    version_match = re.search(rb'version\s*=\s*"([^"]+)"', response)
                    if version_match:
                        device_info["version"] = version_match.group(1).decode('utf-8')
                
                # Check for security indicators
                if b"HTTP/1.1 200" in response and b"requirePassword" not in response:
                    device_info["potential_issue"] = "No authentication required for server-info"
                
                return device_info
            
            return None
            
        except Exception as e:
            logger.debug(f"Error querying {ip}:{port} - {str(e)}")
            return None
    
    def is_version_vulnerable(self, current_version, vulnerable_threshold):
        """Compare version strings to determine if current version is vulnerable"""
        try:
            current_parts = [int(p) for p in current_version.split('.')]
            threshold_parts = [int(p) for p in vulnerable_threshold.split('.')]
            
            # Pad with zeros if needed
            while len(current_parts) < len(threshold_parts):
                current_parts.append(0)
            while len(threshold_parts) < len(current_parts):
                threshold_parts.append(0)
            
            # Compare each part
            for i in range(len(current_parts)):
                if current_parts[i] < threshold_parts[i]:
                    return True
                elif current_parts[i] > threshold_parts[i]:
                    return False
            
            # If all parts are equal, it's at the threshold (not vulnerable)
            return False
        except:
            # If we can't parse the version, assume it might be vulnerable
            return True
    
    def scan_target(self, ip):
        """Scan an IP for AirPlay ports and check for vulnerabilities"""
        open_ports = []
        for port in self.airplay_ports:
            port_result = self.scan_port(ip, port)
            if port_result:
                open_ports.append(port_result)
                
        if open_ports:
            # Found AirPlay ports open, check for vulnerability indicators
            device_info = {
                "ip": ip,
                "open_ports": open_ports,
                "detection_method": "port_scan",
                "device_type": "Unknown AirPlay Device",
                "potentially_vulnerable": True,
                "risk_level": "MEDIUM",  # Default risk level
                "cve": "CVE-2025-24132",
                "vulnerability_indicators": []
            }
            
            # Try to get device info for each open port
            for port in open_ports:
                port_info = self.check_device_info(ip, port)
                if port_info:
                    if "model" in port_info:
                        device_info["device_type"] = port_info["model"]
                    
                    if "version" in port_info:
                        version = port_info["version"]
                        device_info["version"] = version
                        
                        # Check if version matches known vulnerable versions
                        for sig in self.vulnerable_signatures:
                            if "SDK" in sig["version"]:
                                vuln_version = sig["version"].split("< ")[1]
                                if self.is_version_vulnerable(version, vuln_version):
                                    device_info["risk_level"] = sig["risk"]
                                    device_info["vulnerability_indicators"].append(
                                        f"Version {version} matches vulnerable signature: {sig['version']}"
                                    )
                    
                    if "potential_issue" in port_info:
                        device_info["vulnerability_indicators"].append(port_info["potential_issue"])
                    
                    break  # Stop after finding device info from one port
            
            # Custom check for port 7000 (primary AirPlay port)
            if 7000 in open_ports and not any("version" in i for i in device_info["vulnerability_indicators"]):
                device_info["vulnerability_indicators"].append(
                    "Device has port 7000 open but couldn't determine version - potentially vulnerable"
                )
            
            # Determine final vulnerability status
            if device_info["vulnerability_indicators"]:
                device_info["potentially_vulnerable"] = True
                if any("version" in indicator.lower() for indicator in device_info["vulnerability_indicators"]):
                    device_info["risk_level"] = "HIGH"
            else:
                # If we have no specific indicators but the ports are open, it's still potentially vulnerable
                device_info["potentially_vulnerable"] = True
                device_info["risk_level"] = "MEDIUM"
                device_info["vulnerability_indicators"].append("Open AirPlay ports but no specific vulnerability indicators")
            
            # Add to discovered devices
            self.discovered_devices[ip] = device_info
            
            # Log the finding
            if device_info["risk_level"] == "HIGH":
                logger.warning(f"{Colors.FAIL}Found potentially HIGH RISK vulnerable device: {ip}{Colors.ENDC}")
                if device_info["vulnerability_indicators"]:
                    logger.warning(f"{Colors.FAIL}Indicators: {', '.join(device_info['vulnerability_indicators'])}{Colors.ENDC}")
            else:
                logger.info(f"{Colors.WARNING}Found potentially vulnerable device: {ip}{Colors.ENDC}")
                if device_info["vulnerability_indicators"]:
                    logger.info(f"{Colors.WARNING}Indicators: {', '.join(device_info['vulnerability_indicators'])}{Colors.ENDC}")
    
    def scan_network(self):
        """Scan the network for AirPlay devices vulnerable to AirBorne"""
        if self.target_range:
            network = ipaddress.IPv4Network(self.target_range)
        else:
            local_ip = self.get_local_ip()
            network = self.get_network_range(local_ip)
        
        logger.info(f"{Colors.HEADER}Scanning network {network} for devices vulnerable to AirBorne (CVE-2025-24132)...{Colors.ENDC}")
        logger.info(f"{Colors.HEADER}This may take a few minutes...{Colors.ENDC}")
        
        # Prepare target list
        target_ips = [str(ip) for ip in network.hosts()]
        total_hosts = len(target_ips)
        
        logger.info(f"Scanning {total_hosts} hosts for AirPlay vulnerabilities...")
        
        # Multi-threaded scanning
        with ThreadPoolExecutor(max_workers=100) as executor:
            for ip in target_ips:
                executor.submit(self.scan_target, ip)
    
    def mdns_discovery(self):
        """Use mDNS to discover AirPlay services"""
        logger.info(f"{Colors.HEADER}Looking for AirPlay devices with mDNS...{Colors.ENDC}")
        
        class AirPlayListener:
            def __init__(self, scanner):
                self.scanner = scanner
                
            def add_service(self, zeroconf, service_type, name):
                info = zeroconf.get_service_info(service_type, name)
                if info:
                    addresses = [f"{socket.inet_ntoa(addr)}" for addr in info.addresses]
                    for address in addresses:
                        device_info = {
                            "ip": address,
                            "hostname": info.server,
                            "device_type": "AirPlay Device",
                            "detection_method": "mDNS",
                            "service_name": name,
                            "port": info.port,
                            "open_ports": [info.port],
                            "txt_records": {k.decode('utf-8'): v.decode('utf-8') 
                                           for k, v in info.properties.items() if k and v},
                            "potentially_vulnerable": True,
                            "risk_level": "MEDIUM",  # Default risk level
                            "cve": "CVE-2025-24132",
                            "vulnerability_indicators": ["Detected via mDNS as AirPlay device"]
                        }
                        
                        # Check for version information in TXT records
                        txt = device_info["txt_records"]
                        if 'model' in txt and 'version' in txt:
                            model = txt['model']
                            version = txt['version']
                            
                            # Add model and version to device info
                            device_info["device_type"] = model
                            device_info["version"] = version
                            
                            # Determine if potentially vulnerable
                            for signature in self.scanner.vulnerable_signatures:
                                if "SDK" in signature["version"]:
                                    vuln_version = signature["version"].split("< ")[1]
                                    if self.scanner.is_version_vulnerable(version, vuln_version):
                                        device_info["risk_level"] = signature["risk"]
                                        device_info["vulnerability_indicators"].append(
                                            f"Version {version} matches vulnerable signature: {signature['version']}")
                        
                        # Add to discovered devices
                        self.scanner.discovered_devices[address] = device_info
                        
                        # Log the finding
                        if device_info["risk_level"] == "HIGH":
                            logger.warning(f"{Colors.FAIL}Found potentially HIGH RISK vulnerable device via mDNS: {address}{Colors.ENDC}")
                        else:
                            logger.info(f"{Colors.WARNING}Found potentially vulnerable device via mDNS: {address}{Colors.ENDC}")
        
        zeroconf = Zeroconf()
        listener = AirPlayListener(self)
        browser_airplay = ServiceBrowser(zeroconf, "_airplay._tcp.local.", listener)
        browser_raop = ServiceBrowser(zeroconf, "_raop._tcp.local.", listener)
        
        # Give mDNS some time to discover devices
        logger.info("Listening for mDNS announcements for 5 seconds...")
        time.sleep(5)
        zeroconf.close()
    
    def list_discovered_devices(self):
        """Print information about discovered devices"""
        if not self.discovered_devices:
            logger.warning(f"{Colors.WARNING}No vulnerable AirPlay devices discovered.{Colors.ENDC}")
            return
            
        logger.info(f"\n{Colors.HEADER}{Colors.BOLD}Discovered Potentially Vulnerable AirPlay Devices:{Colors.ENDC}")
        logger.info("-" * 80)
        
        high_risk_count = sum(1 for device in self.discovered_devices.values() if device["risk_level"] == "HIGH")
        medium_risk_count = sum(1 for device in self.discovered_devices.values() if device["risk_level"] == "MEDIUM")
        
        logger.info(f"Found {len(self.discovered_devices)} potentially vulnerable devices:")
        logger.info(f"  - {high_risk_count} HIGH risk devices")
        logger.info(f"  - {medium_risk_count} MEDIUM risk devices")
        logger.info("")
        
        for ip, device in self.discovered_devices.items():
            if device["risk_level"] == "HIGH":
                risk_indicator = f"{Colors.FAIL}HIGH RISK{Colors.ENDC}"
            else:
                risk_indicator = f"{Colors.WARNING}MEDIUM RISK{Colors.ENDC}"
                
            logger.info(f"Device: {Colors.BOLD}{device['device_type']}{Colors.ENDC}")
            logger.info(f"IP Address: {ip}")
            logger.info(f"Risk Level: {risk_indicator}")
            logger.info(f"Open AirPlay Ports: {', '.join(map(str, device['open_ports']))}")
            logger.info(f"Detection Method: {device['detection_method']}")
            
            if "hostname" in device:
                logger.info(f"Hostname: {device['hostname']}")
            
            if "version" in device:
                logger.info(f"Version: {device['version']}")
            
            if "vulnerability_indicators" in device and device["vulnerability_indicators"]:
                logger.info(f"Vulnerability Indicators:")
                for indicator in device["vulnerability_indicators"]:
                    logger.info(f"  - {indicator}")
            
            if "txt_records" in device and device["txt_records"]:
                if self.verbose:
                    logger.info(f"Device Info:")
                    for key, value in device["txt_records"].items():
                        logger.info(f"  {key}: {value}")
            
            logger.info("-" * 80)
    
    def export_results(self, filename=None):
        """Export results to a JSON file"""
        if not filename:
            filename = os.path.join(self.output_dir, f"airborne_scan_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
        
        # Convert data for JSON serialization
        export_data = {
            "scan_info": {
                "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "target_range": self.target_range,
                "total_devices": len(self.discovered_devices),
                "high_risk_count": sum(1 for device in self.discovered_devices.values() if device["risk_level"] == "HIGH"),
                "medium_risk_count": sum(1 for device in self.discovered_devices.values() if device["risk_level"] == "MEDIUM")
            },
            "devices": self.discovered_devices
        }
        
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=4)
        
        logger.info(f"{Colors.GREEN}Results exported to {filename}{Colors.ENDC}")
        return filename
    
    def run(self):
        """Run the complete vulnerability check"""
        logger.info(f"{Colors.BOLD}{Colors.HEADER}")
        logger.info("=" * 80)
        logger.info("           AirBorne Vulnerability Checker (CVE-2025-24132)           ")
        logger.info("           For security education and testing only                   ")
        logger.info("=" * 80)
        logger.info(f"{Colors.ENDC}")
        
        # Start with mDNS discovery
        self.mdns_discovery()
        
        # Then do network scanning
        self.scan_network()
        
        # Print and export results
        self.list_discovered_devices()
        results_file = self.export_results()
        
        # Print security recommendations
        logger.info(f"\n{Colors.HEADER}Security Recommendations:{Colors.ENDC}")
        logger.info("1. Update all Apple devices to the latest OS versions")
        logger.info("2. Update firmware on third-party AirPlay devices if updates are available")
        logger.info("3. Consider network segmentation for devices that cannot be updated")
        logger.info("4. Disable AirPlay on devices not actively using it")
        logger.info("5. Monitor for suspicious AirPlay activities on your network")
        
        logger.info(f"\n{Colors.WARNING}This check was performed for educational and security purposes only.{Colors.ENDC}")
        logger.info(f"{Colors.WARNING}Results saved to: {results_file}{Colors.ENDC}")
        
        return len(self.discovered_devices) > 0

def main():
    parser = argparse.ArgumentParser(
        description='AirBorne Vulnerability Checker (CVE-2025-24132) - For security education and testing only',
        epilog='Example: %(prog)s -t 192.168.1.0/24 -o scan_results'
    )
    
    parser.add_argument('-t', '--target', help='Target IP range (CIDR notation, e.g., 192.168.1.0/24)')
    parser.add_argument('-o', '--output', help='Output directory for scan results')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Setup output directory
    output_dir = args.output if args.output else "airborne_scan"
    
    checker = AirBorneChecker(
        target_range=args.target,
        output_dir=output_dir,
        verbose=args.verbose
    )
    
    checker.run()

if __name__ == "__main__":
    main()
